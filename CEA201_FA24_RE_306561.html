<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FA24 Retake Exam</title>
  <style>
    body { font-family: Arial, sans-serif; background:#f8f9fa; margin:0; padding:0; }
    header { background:#343a40; color:white; padding:1rem; text-align:center; }
    h1 { margin:0; font-size:1.5rem; }
    .container { max-width:900px; margin:0 auto; padding:1rem; }
    .question-card { background:white; border:1px solid #ddd; border-radius:4px; padding:1rem; margin-bottom:1rem; box-shadow:0 1px 2px rgba(0,0,0,0.05); }
    .question-title { font-weight:bold; margin-bottom:0.5rem; }
    .options label { display:block; margin:0.25rem 0; cursor:pointer; }
    .explanation { display:none; margin-top:0.5rem; padding:0.5rem; background:#e9ecef; border-radius:4px; }
    .correct { color:green; font-weight:bold; }
    .incorrect { color:red; font-weight:bold; }
    nav { margin-bottom:1rem; }
    nav a { color:#007bff; text-decoration:none; }
    nav a:hover { text-decoration:underline; }
    /* Controls for randomising and resetting the exam */
    .exam-controls { display:flex; flex-wrap:wrap; align-items:center; gap:0.75rem; margin-bottom:1rem; }
    .exam-controls button { padding:0.4rem 0.8rem; border:none; border-radius:4px; background:#007bff; color:white; cursor:pointer; font-size:0.9rem; }
    .exam-controls button:hover { background:#0056b3; }
    .exam-controls span { font-weight:bold; font-size:0.9rem; }
  </style>
</head>
<body>
  <header>
    <h1>FA24 Retake Exam</h1>
  </header>
  <div class="container">
    <nav><a href="index.html">&larr; Back to index</a></nav>
    <div class="exam-controls">
      <button id="randomize-btn">Randomize</button>
      <button id="reset-btn">Reset</button>
      <span id="scoreboard">Score: 0/0</span>
      <span id="timer">Time: 00:00</span>
    </div>
    <div id="questions-container"></div>
  </div>
  <script>
    // Exam data injected from Python
    const examData = [{"number": 1, "question": "Which of the following components was used in the first ENIAC computer?", "options": [{"letter": "A", "text": "Bipolar transistors"}, {"letter": "B", "text": "Field transistors"}, {"letter": "C", "text": "Vacuum tubes"}, {"letter": "D", "text": "Semiconductor ICs"}], "answer_letters": ["C"], "answer_desc": "Vacuum tubes (Ống chân không)", "explanation": "Máy tính ENIAC, một trong những máy tính điện tử đầu tiên, được chế tạo bằng ống chân không, vì vào thời điểm đó các transistor và mạch tích hợp (IC) chưa được phát minh. ", "tips": ""}, {"number": 2, "question": "Which of the following statements is NOT part of the Von Neumann principle?", "options": [{"letter": "A", "text": "Computers can operate according to a stored program"}, {"letter": "B", "text": "The computer uses a program counter to indicate the location of the next statement"}, {"letter": "C", "text": "A computer's memory is addressable"}, {"letter": "D", "text": "Each statement must have a memory area containing the address of the next instruction"}], "answer_letters": ["D"], "answer_desc": "Each statement must have a memory area containing the address of the next instruction", "explanation": "Nguyên lý Von Neumann bao gồm các khái niệm: máy tính hoạt động dựa trên chương trình được lưu trữ, sử dụng bộ đếm chương trình để xác định lệnh tiếp theo, và bộ nhớ có thể địa chỉ hóa. Tuy nhiên, không yêu cầu mỗi lệnh phải có vùng nhớ chứa địa chỉ của lệnh tiếp theo. ", "tips": ""}, {"number": 3, "question": "Regarding the ALU (Arithmetic Logic Unit), besides basic arithmetic operations, what operations can it perform?", "options": [{"letter": "A", "text": "It handles logical operations such as AND, OR, XOR, NOT"}, {"letter": "B", "text": "It handles data transfer operations like MOVE, GO, JUMP"}, {"letter": "C", "text": "It handles decoding operations after an instruction is fetched"}, {"letter": "D", "text": "It handles bit shifting operations like multiplication and division by powers of two"}], "answer_letters": ["A"], "answer_desc": "It handles logical operations such as AND, OR, XOR, NOTD. It handles bit shifting operations like multiplication and division by powers of two", "explanation": "Bộ ALU (Arithmetic Logic Unit) không chỉ thực hiện các phép toán số học cơ bản mà còn thực hiện: Phép toán logic (như AND, OR, XOR, NOT). Dịch bit (bit shifting), dùng để nhân hoặc chia với lũy thừa của 2. ", "tips": ""}, {"number": 4, "question": "Consider some computer generations:1: The first computer generation2: The second computer generation3: The third computer generation", "options": [], "answer_letters": ["C"], "answer_desc": "1-A; 2-B; 3-C", "explanation": " Thế hệ máy tính đầu tiên sử dụng ống chân không (Vacuum Tubes). Thế hệ thứ hai sử dụng transistor. Thế hệ thứ ba sử dụng mạch tích hợp (IC). ", "tips": ""}, {"number": 5, "question": "What electronic component is used to govern operations such as fetching, decoding, and performing arithmetic operations executed by a processor?", "options": [{"letter": "A", "text": "Using a system clock"}, {"letter": "B", "text": "Using a quartz crystal"}, {"letter": "C", "text": "Using an analog-to-digital converter"}, {"letter": "D", "text": "Using a counter"}], "answer_letters": ["A"], "answer_desc": "Using a system clock", "explanation": "Một hệ thống xung nhịp (system clock) được sử dụng để đồng bộ hóa các hoạt động của bộ xử lý, bao gồm nạp lệnh, giải mã, và thực hiện các phép toán. ", "tips": ""}, {"number": 6, "question": "The pulse rate in the clock system is known as the:", "options": [{"letter": "A", "text": "Clock cycle"}, {"letter": "B", "text": "Clock speed"}, {"letter": "C", "text": "Clock time"}, {"letter": "D", "text": "Clock tick"}], "answer_letters": ["B"], "answer_desc": "Clock speed (Tốc độ xung nhịp)", "explanation": "Clock speed là tần số của xung nhịp, đo lường tốc độ thực hiện các hoạt động của CPU trong một giây. ", "tips": ""}, {"number": 7, "question": "The instruction, which adds 1 to the value in a memory location, has five stages: fetch opcode (four cycles), fetch operand address (three cycles), fetch operand (three cycles), add 1 to operand (three cycles), and store operand (three cycles). An interrupt sends a request at the beginning of the fetch operand stage. How many cycles does the processor take to enter the interrupt processing cycle?", "options": [{"letter": "A", "text": "6"}, {"letter": "B", "text": "7"}, {"letter": "C", "text": "8"}, {"letter": "D", "text": "9"}, {"letter": "E", "text": "10"}], "answer_letters": ["C"], "answer_desc": "8", "explanation": " Quá trình thực hiện lệnh gồm các giai đoạn: Fetch opcode (4 chu kỳ). Fetch operand address (3 chu kỳ). Fetch operand (3 chu kỳ) → Ngắt được gửi tại đây. Sau khi hoàn thành 3 chu kỳ trong \"Fetch operand\", CPU cần thêm 5 chu kỳ để xử lý ngắt, tổng cộng: 3 + 5 = 8 chu kỳ. ", "tips": ""}, {"number": 8, "question": "Which representation is most efficient to perform arithmetic operations on signed integer numbers?", "options": [{"letter": "A", "text": "Sign-magnitude"}, {"letter": "B", "text": "2's complement"}, {"letter": "C", "text": "1's & 2's complement"}, {"letter": "D", "text": "1's complement"}], "answer_letters": ["B"], "answer_desc": "2's complement (Bù 2)", "explanation": "Biểu diễn số nguyên có dấu bằng bù 2 là hiệu quả nhất cho các phép toán số học, vì nó loại bỏ sự mơ hồ của số 0 và đơn giản hóa các phép cộng, trừ. ", "tips": ""}, {"number": 9, "question": "Interprets the instructions in memory and causes them to be executed.", "options": [{"letter": "A", "text": "Registers"}, {"letter": "B", "text": "CPU interconnection"}, {"letter": "C", "text": "Arithmetic and Logic Unit (ALU)"}, {"letter": "D", "text": "I/O Modules"}, {"letter": "E", "text": "Control Unit (CU)"}], "answer_letters": ["E"], "answer_desc": "Control Unit (CU)", "explanation": "Control Unit (Bộ điều khiển) có nhiệm vụ giải mã các lệnh trong bộ nhớ và kích hoạt các thành phần liên quan để thực thi lệnh. ", "tips": ""}, {"number": 10, "question": "What is the function of the bus system in the computer?", "options": [{"letter": "A", "text": "Extend the communication function of the computer"}, {"letter": "B", "text": "Connect components in the computer"}, {"letter": "C", "text": "Control peripherals"}, {"letter": "D", "text": "Transform signals in the computer"}, {"letter": "E", "text": "All of the mentioned"}], "answer_letters": ["A"], "answer_desc": "To extend the communication function of the computer", "explanation": ": Hệ thống bus trong máy tính là một kênh giao tiếp giữa các thành phần khác nhau như CPU, bộ nhớ và các thiết bị ngoại vi. Nó không chỉ kết nối các bộ phận trong máy tính mà còn giúp truyền tải dữ liệu giữa các thành phần đó.", "tips": ""}, {"number": 11, "question": "What is the correct order of memory access speed from fastest to slowest?", "options": [{"letter": "A", "text": "Registers > Cache > RAM > SSD"}, {"letter": "B", "text": "Cache > Registers > RAM > SSD"}, {"letter": "C", "text": "Registers > Cache > SSD > RAM"}, {"letter": "D", "text": "Cache > Registers > SSD > RAM"}, {"letter": "E", "text": "All of the mentioned are wrong"}], "answer_letters": ["A"], "answer_desc": "Registers > Cache > RAM > SSD", "explanation": ": Thứ tự tốc độ truy cập bộ nhớ từ nhanh nhất đến chậm nhất là: Registers (được sử dụng trực tiếp bởi CPU), Cache (bộ nhớ đệm giúp truy xuất dữ liệu nhanh), RAM (bộ nhớ truy cập ngẫu nhiên), và SSD (là bộ nhớ lưu trữ chậm nhất trong các lựa chọn này).", "tips": ""}, {"number": 12, "question": "What is the special feature of Memory Cache?", "options": [{"letter": "A", "text": "Allows faster access than DRAM memory"}, {"letter": "B", "text": "Memory cache is outboard storage memory"}, {"letter": "C", "text": "Allows faster access than CPU registers"}, {"letter": "D", "text": "Fixed memory - Read Only Memory"}, {"letter": "E", "text": "Has a larger capacity than HDD"}], "answer_letters": ["A"], "answer_desc": "Allows faster access than DRAM memory", "explanation": ": Bộ nhớ Cache cung cấp tốc độ truy cập nhanh hơn nhiều so với DRAM. Cache thường được dùng để lưu trữ dữ liệu tạm thời mà CPU cần truy cập nhanh.", "tips": ""}, {"number": 13, "question": "A set-associative cache consists of 64 lines, divided into four-line sets. 2192^{19}-words main memory contains 4K blocks of 128 words each. How many bits are there in the tag field of the cache?", "options": [{"letter": "A", "text": "5"}, {"letter": "B", "text": "6"}, {"letter": "C", "text": "7"}, {"letter": "D", "text": "8"}, {"letter": "E", "text": "9"}], "answer_letters": ["B"], "answer_desc": "6", "explanation": ": Để tính số bit trong trường tag của bộ nhớ cache, cần phải tính toán số lượng bit cho block offset, số bit cho chỉ mục (index), và số bit cho tag. Tính toán chi tiết cho ra 6 bit cho trường tag.", "tips": ""}, {"number": 14, "question": "Which one of the following is invalid about RAM?", "options": [{"letter": "A", "text": "Both static and dynamic RAMs are volatile; that is, power must be continuously supplied to the memory to preserve the bit values."}, {"letter": "B", "text": "A dynamic memory cell is simpler and smaller than a static memory cell."}, {"letter": "C", "text": "Both static and dynamic RAMs require the supporting refresh circuitry."}, {"letter": "D", "text": "SRAMs are somewhat faster than DRAMs"}], "answer_letters": ["C"], "answer_desc": "Both static and dynamic RAMs requires the supporting refresh circuitry", "explanation": ": SRAM (Static RAM) không yêu cầu làm mới dữ liệu, nhưng DRAM (Dynamic RAM) cần có mạch làm mới vì nó mất dữ liệu theo thời gian.", "tips": ""}, {"number": 15, "question": "In error-correcting code (single ECC), how many bits are used to correct one bit in 8-bit data?", "options": [{"letter": "A", "text": "4"}, {"letter": "B", "text": "5"}, {"letter": "C", "text": "6"}, {"letter": "D", "text": "7"}], "answer_letters": ["B"], "answer_desc": "5", "explanation": ": Để sửa lỗi một bit trong bộ dữ liệu 8 bit sử dụng mã ECC (Error-Correcting Code), cần ít nhất 5 bit.", "tips": ""}, {"number": 16, "question": "What is correct about increasing performance and endurance?", "options": [{"letter": "A", "text": "Hard Disk > DRAM > NAND Flash > SRAM"}, {"letter": "B", "text": "Hard Disk > NAND Flash > DRAM > SRAM"}, {"letter": "C", "text": "NAND Flash > Hard Disk > SRAM > DRAM"}, {"letter": "D", "text": "Hard Disk > DRAM > SRAM > NAND Flash"}], "answer_letters": ["B"], "answer_desc": "Hard Disk - NAND Flash - DRAM - SRAM", "explanation": ": Để cải thiện hiệu suất và độ bền của hệ thống, thứ tự từ thiết bị lưu trữ chậm nhất đến nhanh nhất là: Hard Disk (chậm nhất), NAND Flash (SSD), DRAM, và SRAM (nhanh nhất).", "tips": ""}, {"number": 17, "question": "With the hard disk data layout, the set of all the tracks in the same relative position on the platter is called:", "options": [{"letter": "A", "text": "Cylinder"}, {"letter": "B", "text": "Tracks"}, {"letter": "C", "text": "Inter-track gap"}, {"letter": "D", "text": "Sector"}], "answer_letters": ["A"], "answer_desc": "Cylinder", "explanation": ": Trong ổ cứng, một Cylinder là tập hợp các track ở cùng một vị trí tương đối trên tất cả các đĩa trong ổ.", "tips": ""}, {"number": 18, "question": "The speed of data delivery is your main concern when configuring a RAID drive for a Media Streaming Server. This server has two hard disks installed. What type of RAID should you install, and what type of data will be stored on Disk 1 and Disk 2?", "options": [{"letter": "A", "text": "RAID 0 - Disk 1 (Stripe) and Disk 2 (Stripe)"}, {"letter": "B", "text": "RAID 0 - Disk 1 (Mirror) and Disk 2 (Mirror)"}, {"letter": "C", "text": "RAID 1 - Disk 1 (Stripe) and Disk 2 (Stripe)"}, {"letter": "D", "text": "RAID 1 - Disk 1 (Mirror) and Disk 2 (Mirror)"}], "answer_letters": ["A"], "answer_desc": "RAID 0 - Disk 1 (Stripe) and Disk 2 (Stripe)", "explanation": ": RAID 0 chia nhỏ dữ liệu và ghi trên các đĩa khác nhau (striping), giúp tăng tốc độ truy xuất dữ liệu, phù hợp với các hệ thống cần tốc độ cao như máy chủ phát video.", "tips": ""}, {"number": 19, "question": "In terms of performance, what is the main advantage of a solid-state drive over a magnetic disk?", "options": [{"letter": "A", "text": "A solid-state drive has faster access time, lower latency, and higher reliability."}, {"letter": "B", "text": "A solid-state drive has larger capacity, lower power consumption, and lower cost."}, {"letter": "C", "text": "A solid-state drive has better compatibility, longer lifespan, and higher security."}, {"letter": "D", "text": "A solid-state drive has none of the mentioned advantages over a magnetic disk."}], "answer_letters": ["A"], "answer_desc": "A solid state drive has faster access time, lower latency, and higher reliability", "explanation": ": SSD (Solid State Drive) có thời gian truy cập nhanh hơn, độ trễ thấp hơn và độ tin cậy cao hơn so với ổ cứng cơ học (HDD) vì không có các bộ phận chuyển động.", "tips": ""}, {"number": 20, "question": "Assume that a truth table:", "options": [], "answer_letters": ["B"], "answer_desc": "OR", "explanation": ": Một bảng chân lý với hai giá trị đầu vào 10 và 1 sẽ trả về kết quả OR. Vì với OR, chỉ cần một trong hai đầu vào là 1, đầu ra sẽ là 1.", "tips": ""}, {"number": 21, "question": "In isolated I/O:", "options": [{"letter": "A", "text": "The I/O devices and the memory share the same address space"}, {"letter": "B", "text": "The I/O devices have a separate address space from memory"}, {"letter": "C", "text": "The memory and I/O devices have an associated address space"}, {"letter": "D", "text": "A part of the memory is specifically set aside for the I/O operation"}, {"letter": "E", "text": "None of the mentioned"}], "answer_letters": ["B"], "answer_desc": "The I/O devices have a separate address space from memory", "explanation": ": Trong I/O isolated, các thiết bị I/O và bộ nhớ có không gian địa chỉ riêng biệt, nghĩa là chúng không chia sẻ cùng một không gian địa chỉ.", "tips": ""}, {"number": 22, "question": "What is an interrupt vector?", "options": [{"letter": "A", "text": "Part of memory which contains the addresses of interrupt handlers"}, {"letter": "B", "text": "A signal an I/O device sends to CPU"}, {"letter": "C", "text": "A signal an I/O software sends to CPU"}, {"letter": "D", "text": "None of the mentioned"}], "answer_letters": ["A"], "answer_desc": "Part of memory which contains the addresses of interrupt handlers", "explanation": ": Interrupt vector là phần bộ nhớ chứa các địa chỉ của interrupt handlers, dùng để xử lý các ngắt từ các thiết bị ngoại vi.", "tips": ""}, {"number": 23, "question": "What is the main distinction between Interrupt-Driven I/O and Direct Memory Access (DMA)?", "options": [{"letter": "A", "text": "Interrupt-Driven I/O involves the CPU in every data transfer, while DMA bypasses the CPU and transfers data directly between I/O device and memory"}, {"letter": "B", "text": "Interrupt-Driven I/O requires special hardware and software support, while DMA does not need any additional components"}, {"letter": "C", "text": "Interrupt-Driven I/O is suitable for small and frequent data transfers, while DMA is suitable for large and infrequent data transfers"}, {"letter": "D", "text": "All of the mentioned"}], "answer_letters": ["A"], "answer_desc": "Interrupt-Driven I/O involves the CPU in every data transfer, while DMA bypasses the CPU and transfers data directly between I/O device and memory", "explanation": ": Interrupt-Driven I/O yêu cầu CPU tham gia vào mỗi lần truyền dữ liệu, trong khi DMA (Direct Memory Access) cho phép truyền tải dữ liệu trực tiếp giữa thiết bị I/O và bộ nhớ mà không cần qua CPU.", "tips": ""}, {"number": 24, "question": "What role does an Application Programming Interface (API) play in software development?", "options": [{"letter": "A", "text": "It allows program access to hardware resources using high-level language libraries"}, {"letter": "B", "text": "It defines low-level machine instructions"}, {"letter": "C", "text": "It provides a standard for binary portability"}, {"letter": "D", "text": "It manages system resources for the operating system and machine language instructions"}], "answer_letters": ["A"], "answer_desc": "It allows program access to hardware resources using high-level language libraries", "explanation": ": API (Application Programming Interface) cho phép chương trình truy cập các tài nguyên phần cứng thông qua các thư viện ngôn ngữ lập trình cấp cao.", "tips": ""}, {"number": 25, "question": "Which state indicates that a process is currently being executed by the processor?", "options": [{"letter": "A", "text": "Running"}, {"letter": "B", "text": "Ready"}, {"letter": "C", "text": "NewBorn"}, {"letter": "D", "text": "Halted"}], "answer_letters": ["A"], "answer_desc": "Running", "explanation": ": Running là trạng thái khi một tiến trình đang được thực thi bởi CPU.", "tips": ""}, {"number": 26, "question": "Which of the following statements is incorrect about Translation Look-aside Buffer (TLB)?", "options": [{"letter": "A", "text": "The use of TLB eliminates the need for keeping a page table in memory"}, {"letter": "B", "text": "TLB only maintains a subset of the entries stored in the full memory-based page table"}, {"letter": "C", "text": "When there is a TLB miss the system needs to access the page table"}, {"letter": "D", "text": "A translation lookaside buffer (TLB) is a memory cache that stores the recent translations of virtual memory to physical memory"}], "answer_letters": ["A"], "answer_desc": "The use of TLB eliminates the need for keeping a page table in memory", "explanation": ": TLB (Translation Lookaside Buffer) lưu trữ một phần của bảng trang và giúp giảm thiểu việc phải truy cập bảng trang trong bộ nhớ.", "tips": ""}, {"number": 27, "question": "How does Boolean algebra contribute to the design of digital circuits?", "options": [{"letter": "A", "text": "It simplifies the implementation of desired functions"}, {"letter": "B", "text": "It helps in the analysis of economic data"}, {"letter": "C", "text": "It facilitates the design of analog circuits"}, {"letter": "D", "text": "It is primarily used for chemical engineering and physical engineering"}], "answer_letters": ["A"], "answer_desc": "It simplifies the implementation of desired functions", "explanation": ": Boolean algebra là công cụ quan trọng trong thiết kế mạch số vì nó giúp đơn giản hóa việc triển khai các hàm logic.", "tips": ""}, {"number": 28, "question": "When both inputs are 0, what is the result of a NOR gate?", "options": [{"letter": "A", "text": "0"}, {"letter": "B", "text": "1"}, {"letter": "C", "text": "2"}, {"letter": "D", "text": "Undefined"}, {"letter": "E", "text": "#NA"}], "answer_letters": ["B"], "answer_desc": "1", "explanation": ": Cổng NOR sẽ trả về 1 khi cả hai đầu vào đều là 0, điều này làm nó trái ngược với cổng OR.", "tips": ""}, {"number": 29, "question": "The operation yields true (binary value 1) if and only if both of its operands are true.", "options": [{"letter": "A", "text": "OR"}, {"letter": "B", "text": "AND"}, {"letter": "C", "text": "XOR"}, {"letter": "D", "text": "NAND"}], "answer_letters": ["B"], "answer_desc": "AND", "explanation": ": Cổng AND trả về giá trị true (1) chỉ khi cả hai toán hạng đều là true (1).", "tips": ""}, {"number": 30, "question": "We have a long-term queue of process requests, typically stored on:", "options": [{"letter": "A", "text": "main memory"}, {"letter": "B", "text": "disk"}, {"letter": "C", "text": "cache memory"}, {"letter": "D", "text": "registers"}], "answer_letters": ["B"], "answer_desc": "disk", "explanation": ": Disk là nơi lưu trữ các yêu cầu tiến trình dài hạn trong hệ thống.", "tips": ""}, {"number": 31, "question": "Which registers can be assigned to a variety of functions by the programmer?", "options": [{"letter": "A", "text": "Data registers"}, {"letter": "B", "text": "General purpose registers"}, {"letter": "C", "text": "Address registers"}, {"letter": "D", "text": "Condition codes (flags)"}], "answer_letters": ["B"], "answer_desc": "General purpose registers", "explanation": ": General purpose registers có thể được lập trình viên gán cho nhiều chức năng khác nhau trong quá trình xử lý.", "tips": ""}, {"number": 32, "question": "The hardware mechanism that allows a device to notify the CPU is called:", "options": [{"letter": "A", "text": "polling"}, {"letter": "B", "text": "interrupt"}, {"letter": "C", "text": "driver"}, {"letter": "D", "text": "controlling"}], "answer_letters": ["B"], "answer_desc": "interrupt", "explanation": ": Interrupt là cơ chế phần cứng cho phép một thiết bị gửi tín hiệu yêu cầu CPU thực hiện một tác vụ.", "tips": ""}, {"number": 33, "question": "What is a branch instruction?", "options": [{"letter": "A", "text": "The instructions that are used to divide a program into multiple subprograms"}, {"letter": "B", "text": "The instructions that have as one of its operands the address of the next instruction to be executed"}, {"letter": "C", "text": "The instructions that are used to pause the program"}, {"letter": "D", "text": "The instructions that are used to return to the beginning of the program"}], "answer_letters": ["B"], "answer_desc": "The instructions that have as one of its operands the address of the next instruction to be executed", "explanation": ": Branch instructions là các lệnh có một trong các toán hạng là địa chỉ của lệnh tiếp theo sẽ được thực thi, cho phép thay đổi dòng chảy chương trình.", "tips": ""}, {"number": 34, "question": "Which of the following statement is correct about addressing modes?", "options": [{"letter": "A", "text": "They define how the operands of an instruction are specified, including immediate, register, direct, and indirect addressing modes"}, {"letter": "B", "text": "Addressing modes are irrelevant in computer architecture, and all instructions only operate on values stored in registers"}, {"letter": "C", "text": "Addressing modes are limited to only immediate and direct modes; register and indirect addressing modes are not used in modern computer systems"}, {"letter": "D", "text": "All instructions in computer architecture use indirect addressing modes, making it the only relevant mode for operand specification"}], "answer_letters": ["A"], "answer_desc": "They define how the operands of an instruction are specified, including immediate, register, direct, and indirect addressing modes", "explanation": ": Addressing modes xác định cách các toán hạng của một lệnh được chỉ định, ví dụ như trực tiếp (direct), gián tiếp (indirect), và ngay lập tức (immediate).", "tips": ""}, {"number": 35, "question": "A benchmark program is running on a 400 MHz processor. The executed program consists of 500 instruction executions, with the following instruction mix and clock cycle count in Table below:", "options": [], "answer_letters": ["A"], "answer_desc": "MIPS rate = 285.7", "explanation": ": Để tính MIPS (Million Instructions Per Second), cần tính tổng số chu kỳ của các lệnh và chia cho thời gian thực thi.", "tips": ""}, {"number": 36, "question": "In MASM32, which OPCODE is used to compare two values?", "options": [{"letter": "A", "text": "COM"}, {"letter": "B", "text": "CMP"}, {"letter": "C", "text": "I"}, {"letter": "F", "text": ".. ELSE"}, {"letter": "D", "text": "TEST"}], "answer_letters": ["B"], "answer_desc": "CMP", "explanation": ": CMP là mã lệnh trong MASM32 dùng để so sánh hai giá trị.", "tips": ""}, {"number": 37, "question": "What is the primary purpose of the \"Fetch instruction\" phase in the operation of a processor?", "options": [{"letter": "A", "text": "To read an instruction from memory"}, {"letter": "B", "text": "To interpret the instruction"}, {"letter": "C", "text": "To perform arithmetic operations on data"}, {"letter": "D", "text": "To write data to memory"}], "answer_letters": ["A"], "answer_desc": "To read an instruction from memory", "explanation": ": Mục đích chính của giai đoạn Fetch instruction là đọc lệnh từ bộ nhớ vào CPU để thực thi.", "tips": ""}, {"number": 38, "question": "What is the role of the registers in a processor?", "options": [{"letter": "A", "text": "Registers in a processor provide fast, temporary storage for data and instructions, facilitating efficient access during instruction execution"}, {"letter": "B", "text": "Registers are only used to store data temporarily during the execution of a program and do not contribute to the processing of instructions"}, {"letter": "C", "text": "Registers are solely responsible for storing data from the main memory and have no involvement in holding instructions or facilitating data manipulation"}, {"letter": "D", "text": "Registers are only necessary when the CPU is idle and have no impact on the speed or efficiency of instruction execution"}], "answer_letters": ["A"], "answer_desc": "Registers in a processor provide fast, temporary storage for data and instructions, facilitating efficient access during instruction execution", "explanation": ": Registers trong CPU cung cấp bộ nhớ tạm thời nhanh chóng cho dữ liệu và lệnh, giúp tăng tốc độ truy xuất khi thực thi lệnh.", "tips": ""}, {"number": 39, "question": "What is the significance of the program counter (PC) in the fetch phase of the instruction cycle?", "options": [{"letter": "A", "text": "The program counter (PC) is not used in the fetch phase, and its role is limited to tracking the number of instructions executed by the CPU"}, {"letter": "B", "text": "The program counter (PC) in the fetch phase holds the memory address of the next instruction to be fetched and executed"}, {"letter": "C", "text": "The program counter (PC) is responsible for executing instructions and has no specific role during the fetch phase"}, {"letter": "D", "text": "The program counter (PC) is only relevant in multi-core processors and does not contribute to the fetch phase of the instruction cycle in single-core systems"}], "answer_letters": ["B"], "answer_desc": "The program counter (PC) in the fetch phase holds the memory address of the next instruction to be fetched and executed", "explanation": ": Program Counter (PC) lưu địa chỉ bộ nhớ của lệnh tiếp theo cần lấy và thực thi trong giai đoạn Fetch.", "tips": ""}, {"number": 40, "question": "Which of the following statement is correct in the context of Instruction Pipelining?", "options": [{"letter": "A", "text": "Instruction Pipelining reduces the efficiency of instruction execution by introducing delays and dependencies between instructions"}, {"letter": "B", "text": "Instruction Pipelining is only effective for specific types of instructions and has no impact on the overall efficiency of instruction execution"}, {"letter": "C", "text": "Instruction Pipelining enhances efficiency by enabling simultaneous execution of multiple instructions in different stages, boosting overall throughput"}, {"letter": "D", "text": "Instruction Pipelining improves efficiency by processing multiple instructions simultaneously, reducing execution time. However, it can face challenges like hazards, introducing delays and impacting overall performance"}], "answer_letters": ["D"], "answer_desc": "Instruction Pipelining improves efficiency by processing multiple instructions simultaneously, reducing execution time. However, it can face challenges like hazards, introducing delays and impacting overall performance", "explanation": ": Instruction Pipelining giúp tăng hiệu suất bằng cách xử lý nhiều lệnh đồng thời. Tuy nhiên, nó có thể gặp phải một số vấn đề như hazards, gây ra độ trễ và ảnh hưởng đến hiệu suất chung.Dưới đây là phần giải thích cho các câu hỏi từ câu 41 đến câu 50: ", "tips": ""}, {"number": 41, "question": "What does CISC stand for?", "options": [{"letter": "A", "text": "Complex Instruction Set Computer"}, {"letter": "B", "text": "Computer Instruction Set Complex"}, {"letter": "C", "text": "Complex Instruction Summarize Computer"}, {"letter": "D", "text": "Computer Instruction Summarize Complex"}], "answer_letters": ["A"], "answer_desc": "Complex Instruction Set Computer", "explanation": ": CISC (Complex Instruction Set Computer) là một loại kiến trúc máy tính có bộ chỉ thị phức tạp, trong đó mỗi lệnh có thể thực hiện nhiều thao tác phức tạp.", "tips": ""}, {"number": 42, "question": "What is one of the advantages of using a register file in computer architecture?", "options": [{"letter": "A", "text": "Reduction in memory accesses, saving time"}, {"letter": "B", "text": "More efficient use of space due to dynamic adaptation"}, {"letter": "C", "text": "Efficient handling of both local and global variables"}, {"letter": "D", "text": "Easier management of cache residency"}], "answer_letters": ["A"], "answer_desc": "Reduction in memory accesses, saving time", "explanation": ": Register file giúp giảm thiểu việc truy xuất bộ nhớ, vì các thanh ghi trong CPU có thể chứa các giá trị tạm thời cần thiết cho việc tính toán, từ đó tiết kiệm thời gian.", "tips": ""}, {"number": 43, "question": "What is the main benefit of using RISC over CISC?", "options": [{"letter": "A", "text": "RISC has more instructions and addressing modes than CISC"}, {"letter": "B", "text": "RISC has faster instruction execution and simpler instruction decoding than CISC"}, {"letter": "C", "text": "RISC has variable-length instruction formats and direct memory access than CISC"}, {"letter": "D", "text": "RISC has more registers and pipelines than CISC"}], "answer_letters": ["B"], "answer_desc": "RISC has faster instruction execution and simpler instruction decoding than CISC", "explanation": ": RISC (Reduced Instruction Set Computer) có ưu điểm là lệnh đơn giản và dễ giải mã hơn, giúp thực thi nhanh chóng so với CISC, vốn có bộ lệnh phức tạp.", "tips": ""}, {"number": 44, "question": "In SuperScalar computer architecture, the primary goal of utilizing multiple processors concurrently is to", "options": [{"letter": "A", "text": "Increase processing speed by increasing CPU frequency"}, {"letter": "B", "text": "Improve performance by executing more than one instruction per machine cycle"}, {"letter": "C", "text": "Reduce the size of the CPU to conserve energy"}, {"letter": "D", "text": "Enhance computational power by increasing the number of CPU cores"}], "answer_letters": ["B"], "answer_desc": "Improve performance by executing more than one instruction per machine cycle", "explanation": ": SuperScalar là kiến trúc cho phép thực thi nhiều lệnh trong một chu kỳ máy, giúp tăng hiệu suất tổng thể của hệ thống.", "tips": ""}, {"number": 45, "question": "is (are) determined by the number of instructions that can be fetched and executed at the same time (the number of parallel pipelines) and by the speed and sophistication of the mechanisms that the processor uses to find independent instructions.", "options": [{"letter": "A", "text": "Instruction-level parallelism"}, {"letter": "B", "text": "Machine parallelism"}, {"letter": "C", "text": "Both instruction-level parallelism and machine parallelism"}, {"letter": "D", "text": "None of the mentioned"}], "answer_letters": ["A"], "answer_desc": "Instruction-level parallelism", "explanation": ": Instruction-level parallelism (ILP) đề cập đến khả năng thực thi các lệnh song song trong một chu kỳ máy, tùy thuộc vào số lượng pipeline và khả năng tìm kiếm lệnh độc lập.", "tips": ""}, {"number": 46, "question": "\"Multiple processors share a single memory or pool of memory by means of a shared bus or other interconnection mechanism; a distinguishing feature is that the memory access time to any region of memory is approximately the same for each processor\". Which concept does the statement belong to?", "options": [{"letter": "A", "text": "Symmetric multiprocessor (SMP)"}, {"letter": "B", "text": "Nonuniform memory access (NUMA)"}, {"letter": "C", "text": "Cluster"}, {"letter": "D", "text": "Single instruction, multiple data (SIMD)"}], "answer_letters": ["A"], "answer_desc": "Symmetric multiprocessor (SMP)", "explanation": ": SMP là một hệ thống nhiều bộ xử lý chia sẻ bộ nhớ chung, với đặc điểm là tất cả các bộ xử lý có thời gian truy cập bộ nhớ gần như nhau.", "tips": ""}, {"number": 47, "question": "Which write technique in which all write operations are made to main memory as well as to the cache, ensuring that main memory is always valid.", "options": [{"letter": "A", "text": "Write through"}, {"letter": "B", "text": "Write back"}, {"letter": "C", "text": "Write around"}, {"letter": "D", "text": "No write allocate"}], "answer_letters": ["A"], "answer_desc": "Write through", "explanation": ": Write-through là kỹ thuật trong đó mỗi thao tác ghi dữ liệu được thực hiện đồng thời lên bộ nhớ chính và bộ nhớ cache, đảm bảo bộ nhớ chính luôn có dữ liệu hợp lệ.", "tips": ""}, {"number": 48, "question": "How does multithreading improve the performance of a processor?", "options": [{"letter": "A", "text": "It increases the instruction-level parallelism by issuing multiple instructions from different threads in the same cycle"}, {"letter": "B", "text": "It increases the thread-level parallelism by executing multiple threads on different cores or processors"}, {"letter": "C", "text": "It increases the utilization of the processor resources by hiding the latency of long-latency events such as cache misses or branch mispredictions"}, {"letter": "D", "text": "All of the mentioned"}], "answer_letters": ["C"], "answer_desc": "It increases the utilization of the processor resources by hiding the latency of long-latency events such as cache misses or branch mispredictions", "explanation": ": Multithreading cải thiện hiệu suất của CPU bằng cách giấu đi độ trễ của các sự kiện dài hạn như lỗi truy xuất cache hoặc dự đoán nhánh sai.", "tips": ""}, {"number": 49, "question": "Follow the Amdahl's law for multiprocessors, if only 10% of the code is inherently serial (f = 0.9), running the program on a multicore system with 4 processors, a performance gain (speedup factor) would be", "options": [{"letter": "A", "text": "307%"}, {"letter": "B", "text": "297%"}, {"letter": "C", "text": "317%"}, {"letter": "D", "text": "327%"}], "answer_letters": ["A"], "answer_desc": "", "explanation": "", "tips": ""}, {"number": 50, "question": "What is the most common mapping technique used in cache memory in modern computers?", "options": [{"letter": "A", "text": "Direct Mapping"}, {"letter": "B", "text": "Fully Associative"}, {"letter": "C", "text": "Set Associative"}, {"letter": "D", "text": "None of the mentioned"}], "answer_letters": ["C"], "answer_desc": "Set Associative", "explanation": ": Kỹ thuật ánh xạ bộ nhớ cache phổ biến nhất trong các máy tính hiện đại là Set Associative, nơi mỗi block có thể được ánh xạ đến nhiều \"bucket\" trong cache, làm giảm khả năng xảy ra xung đột.", "tips": ""}];
    // Working copy used for randomization
    let currentQuestions = [];
    // Timer state
    let secondsElapsed = 0;
    let timerInterval = null;

    /**
     * Build the DOM for each question and attach event handlers.
     */
    function renderQuestions() {
      const container = document.getElementById('questions-container');
      // clear any previous content
      container.innerHTML = '';
      currentQuestions.forEach((q, index) => {
        // create card
        const card = document.createElement('div');
        card.className = 'question-card';
        // title
        const title = document.createElement('div');
        title.className = 'question-title';
        // Use double curly braces inside the JS template literal to prevent Python f-string
        // interpolation. Without escaping, Python would try to substitute a Python variable
        // named `index`, which does not exist, leading to a NameError at runtime. Using
        // `${index + 1}` preserves the intended JavaScript interpolation syntax.
        title.textContent = `Question ${index + 1}: ${q.question}`;
        card.appendChild(title);
        // options
        const optsDiv = document.createElement('div');
        optsDiv.className = 'options';
        // determine input type: radio for single answer, checkbox for multiple
        const isMulti = Array.isArray(q.answer_letters) && q.answer_letters.length > 1;
        const inputType = isMulti ? 'checkbox' : 'radio';
        // Escape curly braces for JavaScript template literal variables. Without
        // doubling the braces, Python's f-string engine would attempt to
        // interpolate `index` as a Python variable. Using `${index}` preserves
        // the intended JavaScript variable interpolation.
        const groupName = `q_${index}`;
        q.options.forEach(opt => {
          // Likewise escape variables within the option ID.
          const id = `q_${index}_${opt.letter}`;
          const label = document.createElement('label');
          const input = document.createElement('input');
          input.type = inputType;
          input.name = groupName;
          input.value = opt.letter;
          input.id = id;
          label.appendChild(input);
          const span = document.createElement('span');
          // Escape curly braces for option label interpolation.
          span.textContent = `${opt.letter}. ${opt.text}`;
          label.appendChild(span);
          optsDiv.appendChild(label);
          // attach event listener to reveal answer on change
          input.addEventListener('change', () => handleSelection(index));
        });
        card.appendChild(optsDiv);
        // explanation area
        const expDiv = document.createElement('div');
        expDiv.className = 'explanation';
        card.appendChild(expDiv);
        container.appendChild(card);
      });
      // update scoreboard denominator when rendering questions
      const scoreEl = document.getElementById('scoreboard');
      if (scoreEl) {
        scoreEl.textContent = `Score: 0/${currentQuestions.length}`;
      }
    }

    /**
     * Handle a user's selection by revealing the correct answer and
     * explanation.  The explanation includes the answer letter(s), any
     * answer description, the detailed explanation and an optional tip.
     *
     * @param {number} index The index of the question in the examData array.
     */
    function handleSelection(index) {
      const q = currentQuestions[index];
      const card = document.getElementsByClassName('question-card')[index];
      const expDiv = card.querySelector('.explanation');
      // mark selected options as correct/incorrect
      const inputs = card.querySelectorAll('input');
      inputs.forEach(input => {
        const label = input.parentElement;
        label.classList.remove('correct', 'incorrect');
        if (input.checked) {
          if (q.answer_letters.includes(input.value)) {
            label.classList.add('correct');
          } else {
            label.classList.add('incorrect');
          }
        }
      });
      // build explanation HTML
      let html = '';
      const ansLetters = q.answer_letters.join(', ');
      // Build the explanation HTML using escaped curly braces to avoid
      // Python-side interpolation. We compute ansLetters above; embed
      // JavaScript variables with ${} inside template literals.
      html += `<p><strong>Correct answer:</strong> ${ansLetters}`;
      if (q.answer_desc) {
        html += ` - ${q.answer_desc}`;
      }
      html += `</p>`;
      if (q.explanation) {
        html += `<p><strong>Explanation:</strong> ${q.explanation}</p>`;
      }
      if (q.tips) {
        html += `<p><strong>Tip:</strong> ${q.tips}</p>`;
      }
      expDiv.innerHTML = html;
      expDiv.style.display = 'block';
      // update score after selection
      updateScore();
    }

    /**
     * Compute and update the score display based on the current selections.
     */
    function updateScore() {
      let correctCount = 0;
      currentQuestions.forEach((q, idx) => {
        const card = document.getElementsByClassName('question-card')[idx];
        const inputs = card.querySelectorAll('input');
        const selected = [];
        inputs.forEach(inp => {
          if (inp.checked) selected.push(inp.value);
        });
        if (selected.length > 0) {
          const sortedSel = selected.slice().sort().join('');
          const sortedAns = q.answer_letters.slice().sort().join('');
          if (sortedSel === sortedAns) correctCount++;
        }
      });
      const scoreEl = document.getElementById('scoreboard');
      if (scoreEl) {
        scoreEl.textContent = `Score: ${correctCount}/${currentQuestions.length}`;
      }
    }

    /**
     * Clear all selections and explanations, reset the score and timer.
     */
    function resetExam() {
      const cards = document.getElementsByClassName('question-card');
      [...cards].forEach((card) => {
        const inputs = card.querySelectorAll('input');
        inputs.forEach(inp => {
          inp.checked = false;
          inp.parentElement.classList.remove('correct', 'incorrect');
        });
        const expDiv = card.querySelector('.explanation');
        expDiv.style.display = 'none';
        expDiv.innerHTML = '';
      });
      const scoreEl = document.getElementById('scoreboard');
      if (scoreEl) {
        scoreEl.textContent = `Score: 0/${currentQuestions.length}`;
      }
      resetTimer();
    }

    /**
     * Shuffle an array in place using Fisher–Yates.
     */
    function shuffleArray(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    /**
     * Start the exam timer from zero.
     */
    function startTimer() {
      secondsElapsed = 0;
      const timerEl = document.getElementById('timer');
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        secondsElapsed++;
        const mins = Math.floor(secondsElapsed / 60).toString().padStart(2, '0');
        const secs = (secondsElapsed % 60).toString().padStart(2, '0');
        if (timerEl) {
          timerEl.textContent = `Time: ${mins}:${secs}`;
        }
      }, 1000);
    }

    /**
     * Reset the timer display and restart counting from zero.
     */
    function resetTimer() {
      const timerEl = document.getElementById('timer');
      secondsElapsed = 0;
      if (timerEl) {
        timerEl.textContent = 'Time: 00:00';
      }
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        secondsElapsed++;
        const mins = Math.floor(secondsElapsed / 60).toString().padStart(2, '0');
        const secs = (secondsElapsed % 60).toString().padStart(2, '0');
        if (timerEl) {
          timerEl.textContent = `Time: ${mins}:${secs}`;
        }
      }, 1000);
    }

    /**
     * Initialise the exam: copy question data, render, attach handlers, and start timer.
     */
    function initializeExam() {
      currentQuestions = examData.slice();
      renderQuestions();
      // Bind randomize button
      const randBtn = document.getElementById('randomize-btn');
      if (randBtn) {
        randBtn.addEventListener('click', () => {
          shuffleArray(currentQuestions);
          renderQuestions();
          resetTimer();
          updateScore();
        });
      }
      // Bind reset button
      const resetBtn = document.getElementById('reset-btn');
      if (resetBtn) {
        resetBtn.addEventListener('click', () => {
          resetExam();
        });
      }
      startTimer();
      updateScore();
    }

    // Initialise the page once DOM is ready
    document.addEventListener('DOMContentLoaded', initializeExam);
  </script>
</body>
</html>
